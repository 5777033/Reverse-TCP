import socket
import threading
import select
import logging

logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s][%(levelname)s] %(message)s')

PUBLIC_IP = '0.0.0.0'
SERVER_PORT = 6000  # 只使用一个端口
PROXY_PORTS = {6001: 22, 6002: 80}

clients = {}
pending_conn = {}  # key: (client_id, proxy_port), value: external_sock

def relay(s1, s2):
    try:
        sockets = [s1, s2]
        logging.debug("开始数据转发线程")
        while True:
            r, _, _ = select.select(sockets, [], [])
            for sock in r:
                data = sock.recv(4096)
                if not data:
                    logging.debug("检测到一端连接关闭，退出转发")
                    return
                logging.debug(f"转发数据 {len(data)} 字节")
                if sock is s1:
                    s2.sendall(data)
                else:
                    s1.sendall(data)
    except Exception as e:
        logging.error(f"relay出错: {e}")
    finally:
        s1.close()
        s2.close()
        logging.debug("转发连接关闭")

def handle_proxy_port(proxy_port):
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((PUBLIC_IP, proxy_port))
    srv.listen(50)
    logging.info(f"代理端口启动: {proxy_port}")
    while True:
        sock, addr = srv.accept()
        logging.info(f"外部连接 {addr} -> {proxy_port}")
        if not clients:
            logging.warning("无客户端注册，关闭外部连接")
            sock.close()
            continue
        client_id, ctrl = next(iter(clients.items()))
        try:
            ctrl.sendall(f"NEW_CONN {proxy_port}\n".encode())
            pending_conn[(client_id, proxy_port)] = sock
            logging.debug(f"已通知客户端建立数据通道，等待client回连 {client_id}")
        except Exception as e:
            logging.error(f"通知客户端失败: {e}")
            sock.close()

def handle_client_connection(conn):
    try:
        # 接收第一个消息判断是控制连接还是数据连接
        header = conn.recv(64).decode().strip()
        if not header:
            return

        if ' ' in header:  # 数据连接格式: "client_id port"
            # 处理数据连接
            cid, port = header.split()
            port = int(port)
            logging.info(f"数据通道建立: {cid} -> {port}")
            key = (cid, port)
            if key in pending_conn:
                external = pending_conn.pop(key)
                logging.debug("匹配到外部连接，开始relay")
                relay(external, conn)
            else:
                logging.warning("未找到匹配的外部连接，关闭数据通道")
                conn.close()
        else:  # 控制连接格式: "client_id"
            # 处理控制连接
            cid = header
            clients[cid] = conn
            logging.info(f"客户端注册成功: {cid}")
            try:
                while True:
                    data = conn.recv(1024)
                    if not data:
                        break
                    cmd = data.decode().strip()
                    logging.debug(f"控制通道接收: {cmd}")
            finally:
                for k in list(pending_conn.keys()):
                    if k[0] == cid:
                        pending_conn[k].close()
                        pending_conn.pop(k)
                if cid in clients:
                    del clients[cid]
                logging.info(f"客户端断开: {cid}")
    except Exception as e:
        logging.error(f"处理连接出错: {e}")
    finally:
        conn.close()

def main_server():
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((PUBLIC_IP, SERVER_PORT))
    srv.listen(100)
    logging.info(f"服务器启动，监听端口: {SERVER_PORT}")

    # 启动代理端口线程
    for p in PROXY_PORTS:
        threading.Thread(target=handle_proxy_port, args=(p,), daemon=True).start()

    while True:
        conn, addr = srv.accept()
        logging.debug(f"新连接来自 {addr}")
        threading.Thread(target=handle_client_connection, args=(conn,), daemon=True).start()

if __name__ == "__main__":
    main_server()
