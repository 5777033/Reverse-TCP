root@hcss-ecs-accf:/data/Reverse-TCP# cat server.py
import socket
import threading
import select
import logging

logging.basicConfig(level=logging.DEBUG, format='[%(asctime)s][%(levelname)s] %(message)s')

PUBLIC_IP = '0.0.0.0'
CONTROL_PORT = 6000
DATA_PORT = 6005  # 数据通道端口
PROXY_PORTS = {6001: 22, 6002: 80}

clients = {}
pending_conn = {}  # key: (client_id, proxy_port), value: external_sock

def relay(s1, s2):
    try:
        sockets = [s1, s2]
        logging.debug("开始数据转发线程")
        while True:
            r, _, _ = select.select(sockets, [], [])
            for sock in r:
                data = sock.recv(4096)
                if not data:
                    logging.debug("检测到一端连接关闭，退出转发")
                    return
                logging.debug(f"转发数据 {len(data)} 字节")
                if sock is s1:
                    s2.sendall(data)
                else:
                    s1.sendall(data)
    except Exception as e:
        logging.error(f"relay出错: {e}")
    finally:
        s1.close()
        s2.close()
        logging.debug("转发连接关闭")

def handle_proxy_port(proxy_port):
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((PUBLIC_IP, proxy_port))
    srv.listen(50)
    logging.info(f"代理端口启动: {proxy_port}")
    while True:
        sock, addr = srv.accept()
        logging.info(f"外部连接 {addr} -> {proxy_port}")
        if not clients:
            logging.warning("无客户端注册，关闭外部连接")
            sock.close()
            continue
        client_id, ctrl = next(iter(clients.items()))
        try:
            ctrl.sendall(f"NEW_CONN {proxy_port}\n".encode())
            pending_conn[(client_id, proxy_port)] = sock
            logging.debug(f"已通知客户端建立数据通道，等待client回连 {client_id}")
        except Exception as e:
            logging.error(f"通知客户端失败: {e}")
            sock.close()

def handle_data_channel(conn):
    try:
        header = conn.recv(64).decode().strip()
        logging.debug(f"数据通道握手信息: {header}")
        cid, port = header.split()
        port = int(port)
        logging.info(f"数据通道建立: {cid} -> {port}")
        key = (cid, port)
        if key in pending_conn:
            external = pending_conn.pop(key)
            logging.debug("匹配到外部连接，开始relay")
            relay(external, conn)
        else:
            logging.warning("未找到匹配的外部连接，关闭数据通道")
            conn.close()
    except Exception as e:
        logging.error(f"数据通道错误: {e}")
        conn.close()

def data_server():
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((PUBLIC_IP, DATA_PORT))
    srv.listen(100)
    logging.info(f"数据通道监听启动: {DATA_PORT}")
    while True:
        c, addr = srv.accept()
        logging.debug(f"收到客户端数据通道连接 {addr}")
        threading.Thread(target=handle_data_channel, args=(c,), daemon=True).start()

def handle_control(ctrl):
    """客户端注册"""
    try:
        cid = ctrl.recv(64).decode().strip()
        if not cid:
            return
        clients[cid] = ctrl
        logging.info(f"客户端注册成功: {cid}")
        while True:
            data = ctrl.recv(1024)
            if not data:
                break
            logging.debug(f"控制通道接收数据: {data}")
    finally:
        for k in list(pending_conn.keys()):
            if k[0] == cid:
                pending_conn[k].close()
                pending_conn.pop(k)
        if cid in clients:
            del clients[cid]
        ctrl.close()
        logging.info(f"客户端断开: {cid}")

def control_server():
    srv = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    srv.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
    srv.bind((PUBLIC_IP, CONTROL_PORT))
    srv.listen(5)
    logging.info(f"控制端口监听: {CONTROL_PORT}")
    while True:
        c, addr = srv.accept()
        logging.debug(f"新客户端控制连接 {addr}")
        threading.Thread(target=handle_control, args=(c,), daemon=True).start()

if __name__ == "__main__":
    threading.Thread(target=data_server, daemon=True).start()
    for p in PROXY_PORTS:
        threading.Thread(target=handle_proxy_port, args=(p,), daemon=True).start()
    control_server()
